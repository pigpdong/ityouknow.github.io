---
layout:     post
title:    轻松构建微服务之分布式事物
no-post-nav: true
category: other
tags: [arch]
excerpt: 2PC TCC MQ
---

## 单机事物

> 事物的定义

提高并发
     让多步操作顺序执行

> 解决事物的方法

- 串行
- 排他锁
- 读写锁   （解决的是读读，读的时候可以读但是不能写）
- MVCC    （解决的是写读，别人在写但是还没提交，可以读到以前版本的数据）

> 事物的隔离级别

- 读未提交 read uncommited 可以读取到未提交的数据，生产环境基本不用
- 读已提交  可以读取已经提交的数据，对读取到的数据加锁，读取到的数据不允许修改，但是可以插入数据，这样第二次查询就比第一次多，就会出现幻读
- 可重复读  可重复读，不会出现幻读，对读取到的数据加锁，并对查询范围加锁也就是间隙锁保证其他线程不能插入
- 并行  用读写锁，读加读锁，可以运行其他线程读不允许其他线程写，写加写锁，不允许其他线程读写，所有的读都是当前读，并发读太差不建议使用

以上为SQL92标准，后来出现了一个新的隔离级别
- 快照读，主要用到copyOnwrite,无锁来实现，在读未提交的情况下不会出现不可重复读，也就是mysql用到的MVCC，主要针对读多写少  不用锁也可以实现某些并发场景下的一致性



> ACID

- A:原子性

要么同时成功，要么同时失败，mysql怎么实现，如何回滚？  undolog  ,中间状态给外界看到其实是一致性要解决的问题，A转给B 100块钱，A减了100B还没加，这是一个中间状态，这个中间状态不能被外面看到，这个就是一致性，和原子性没关系，原子性只保证全部成功全部失败，回滚到哪个版本

- C.一致性

一个事物单元要在数据全部提交后才可见，一般靠加锁来实现，强一致性就是加大锁的粒度，目前数据库并不是让所有的事物串行，而是把锁的粒度减小到每一步数据的处理。(一个事物单元要在数据全部提交后才允许下一个事物进来，这种就是串行，严重影响吞吐量，可以完全保证强一致性)

- I. 隔离性

其实是为了解决强一致性性能太差的一种平衡方案，以性能为理由对强一致性的破坏。（序列化读：排他锁，可重复读：读写锁，只能做到读读可并行，不能做到写读并行，读已经提交：会出现不可重复读，读未提交：只加写锁，不加读锁，只有写写不能并行）

- D.持久性

事物完成后，该事物对数据库的更改便持久的保存在数据库中，写完数据后数据不丢 （RAID，写到多个磁盘保证磁盘损坏数据不丢，如何保证写到多个磁盘可以同时成功或者同时失败）不可能每次写数据都要sync到磁盘，性能太差，肯定会再内存缓存，在刷到磁盘，但是内存在断电会丢。

> 处理事物面临的问题

谁先谁后 （一个读请求应该读哪个写请求之后的数据？）
故障恢复 （回滚，和crash-safe）
怎么检查死锁 （队列）



死锁
    读写锁来做读已提交，在同一个事物内先读后写，先上读锁，然后在锁升级为写锁，升级写锁的时候需要等其他事物的读锁释放，如果其他事物也有写请求，就会产生死锁，update set a = a - 1 where id = 1;  U锁就是数据库自动判断后面的sql语句如果是读取后有update,自动上U锁

哲学家问题
    5个哲学家围做一个餐桌，餐桌上有一盘意大利面，每两个哲学家之间放一把餐叉，哲学家必须分别左手和右手都拿到餐叉才能吃东西，如果每个哲学家都左手拿一把餐叉，等右边的餐叉就产生死锁，可以设计一个超时时间，如果5分钟后拿不到就放开左边的餐叉过5分钟在尝试，但是如果5个人同时进入餐厅还是会产生死锁，一种解法是餐厅有个服务生作为协调，哲学家拿餐叉需要经过服务生的同意，另外一种解法是，将餐叉编号，哲学家按顺序从一个方向获取，如果做成一个环释放的可以被其他人获取就是一个ringbuffer

拜占庭将军问题  ：在存在消息丢失的不可信信道上通过消息传递的方式得到一致性是不可能的
    由于当时拜占庭帝国国土辽阔，为了防御目的，每个军队都分隔很远，将军和将军之间只能靠信差来通信，但是军队内可能存在间谍和叛徒，那么如何在已知有叛徒的情况下，在其他忠诚的将军之间达成一致性协定。映射到网络问题，例如网络被劫持，网络不可达等


多机事物
CAP

一致性协议 raft

1.通过选举保证集群中只有一个leader,只有leader对外提供写服务，leader将日志广播给follower,每一条日志都按顺序维护在一个队列里，所有节点的队列里有一个index来控制前面的是已经提交的，后面的是没提交的，提交代表已经有超过半数的节点应答，leader先把日志复制给所有follower，在收到半数节点应答后在通知follower,index位置来控制那些日志是已经提交的，只有提交过的日志，follower才会提供给应用方使用

2、选举过程，当一个leader长时间没有应答时，所有的follower都可以成为candidate，向其他follower节点发送投票请求，如果超过半数follower节点应答后这个candidate就会升级为leader,为了避免所有的follower节点已经作为candidate发起投票，引入随机超时机制，每个follower和leader的超时时间在一定范围内随机，当candidate发起投票没有结果时，随机等待一定时间。

3.candidate的日志长度要大于等于半数follower节点的日志才能成为leader,所以发起投票的时候如果follower发现自己的日志长度大于后选择的就会投反对票

4.日志补齐，当leader发生故障的时候，各个follower上的状态不一样，所以新leader产生后需要补齐所有follow的日志，而且新leander的日志也不一定是最长的，但是foller日志上面没有的日志肯定是未提交的，这个时候补齐就可以

5.老leader复活，每一次选举到下一次选举的时间称为一个term任期，每一个任期内都会维护一个数字并自增，当leader发送复制请求的时候会带上term编号，如果follower发现term比自己小就拒绝，


raft设计中只有两个rpc请求，一个选举，一个复制日志，复制日志顺便做了心跳检测，当没有日志复制的时候发送空日志，


触发选举的唯一条件是 election timeout到期，每一个节点的 election timeout都会将自己设置为candidate然后发起投票，每个节点的election timeout都会存在一个随机值，所以不同，当一个节点被选为leader后会定期向所有的follower发送心跳包，follower收到心跳包后会延长election timeout的值。

节点选举的时候term值大的会优先于term值小的，每一轮选举term值都会加1

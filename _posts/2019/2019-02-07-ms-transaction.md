---
layout:     post
title:    轻松构建微服务之单机事物
no-post-nav: true
category: other
tags: [arch]
excerpt: ACID MVCC
---

## 单机事物

> 事物的定义

我们知道,一个计算机的CPU同一时刻,要么在写数据,要么在计算,要么在读数据,所有的任务都是这3件事情的集合,计算机都是支持多任务的,也就是会为每一个任务分配一个CPU使用时间,在这个时间内只有被分配时间的任务可以使用CPU进行读写和计算,时间到了之后,会让出CPU给其他任务用,这样看起来就像多个任务在并行的执行.

当多个任务并行运行的时候,如果这些任务都会读写同一份文件,假设这个文件存储在硬盘上,一个任务在读,一个任务在写,这样肯定会出问题,而事物相当于在任务的读写计算之外,增加了一个同步模块,让任务按照我们需要的顺序执行,并且不会出现数据的不一致,这就是事物.

当然,如果让多个任务能够一个一个顺序执行,第一个处理完在处理第二个,这样不存在竞争,那么这样一个任务肯定是满足事物的ACID的,但是当我们有多个CPU的话,这种所有任务顺序执行肯定是不可取的,当然单cpu下性能也会有影响,因为当一个任务内有睡眠,或者IO等待操作的时候,实际上CPU这个时候是空闲的,但是也不能让出执行权给其他任务,造成了CPU的浪费,所以事物的本质应该是在并发任务执行的环境下,让任务还能有高效的处理速度.

当然,在单线程环境下如果只有纯碎的计算,这样就没有CPU上下文切换带来的损害,性能反而会越高,redis就是这种实现.


> 事物的ACID

通过上面的分析我们发现,事物其实就是在协调多个任务在读写共享资源的时候,来协调哪个任务先读写,哪个任务后读写,避免造成冲突,同时尽可能减小这个协调操作引起的性能问题,那么怎样才能算读写不冲突呢,我们可以根据事物的4个特性来分析.

- A:原子性

一个事物内的操作,要么同时成功，要么同时失败，一个事物是为了满足一个目标,而事物内的操作都是为了最终完成这个目标,原子性避免了系统只执行了这些操作的一个子集.

mysql利用undolog来实现事物的回滚,每一个操作都会记录对应的undolog,例如insert操作对应的delete就是undolog,如果事物最终决定回滚,将会按顺序依次执行相关的undolog可以回到起始状态,不允许执行到一半就返回,要么全部执行完,要么全部回滚.

- C.一致性

一致性是最难理解的,官方给出的解释是,在事物完成的时候必须使所有的数据都保持一致的状态,但是并没有解释什么是一致状态,什么情况下会破坏一致状态.

我们可以举一个例子,在一个事物中我读取到a的值是5,那么只要我不对a做修改,那么我在这个事物内的任意时刻继续读a的值,他永远是5不可能改变,这个就是数据的一致性,
在比如,我们修改一个变量b的值为3,那么当事物提交后,持久化后磁盘上的数据就应该是3不可能是其他值,这个就是一致性的含义.

那么怎样才能保证数据的一致性呢,或者什么情况下才能出现数据的不一致性呢?

还是上面的例子,如果我先查询取到a的值为3,那么其他线程将a的值改为1,那么我在这个事物内在查询a的值发现变成了1,这就出现了不一致,我们可以看到,事物的一致性其实是在讲一个事物单元的中间状态是否要对其他事物可见,例如另一个线程将a的值改为1,但是这个修改只有他这个线程看的到,其他线程看不到那么原来的线程继续查询a的值就会发现还是3.

一个事物单元要在数据全部提交后才可见，这就是一致性想表达的内容,在举个例子A给B转账100块钱，A减了100块钱,B还没加上去的时刻，这就是一个中间状态，这个中间状态不能被外面看到，这个就是一致性.

怎么才能实现一致性呢,没错,就是加锁,让有资源竞争的事物顺序执行,例如数据库的表锁,行锁等,要达到强一致性就要加互斥锁才能保证.

- I. 隔离性


隔离性其实是为了解决强一致性性能太差的一种平衡方案，以性能为理由对强一致性的破坏,官方的解释是多个事物之间互不干扰,在A事物执行的时候,不能影响到B事物的结果,例如一个线程在做A给B转转100,而另外一个线程在做A给C转100块钱,而A只有100元.两个线程能够同时对A进行操作就是违背了隔离性,

但是隔离性定了一些级别,如果一个事物在对数据A进行写操作,那么是否允许另外一个线程读取A呢? 其实就是在两个事物之间的读读,读写,写读,写写,定义了一些标准,不同的标准可能有适合的场景,主要是在性能和一致性级别上做权衡,下面我们一起看下SQL92标准定义的事物4种隔离级别.

- 1.读未提交 read uncommited 可以读取到未提交的数据，生产环境基本不用,因为太容易造成数据不一致了,例如事物A读取到了a的值为5,另外一个事物将a的值改为4,那么事物A由于可以读取到未提交的值,那么当a在读a的值发现a为4和之前的5不一样,这就出现了不可重复读,再举一个例子,事物A查询a的值发现为4,但是这个值
是事物B刚从a=3修改过来的,不过事物B由于其他问题进行了rollback操作,将a的值改为3,那么事物a就出现了脏读,在比如,事物A查询名字叫小强的人有4个人,然后事物B又往里面插入了一个叫小强的记录,结果事物A在去读的时候发现有5个叫小强的人,这个就是幻读,所以在读未提交的情况下,会出现幻读,不可重复读,脏读.

- 2.读已提交  可以读取已经提交的数据，这种隔离级别由于不会读取到别人未提交的数据,所以不会出现脏读,但是也会出现不可重复读,因为虽然读取到的是别人提交后的数据,但是在别人提交前读和提交后读还是不一样,当然,幻读也无法避免.

- 3.可重复读  可以重复读,这种隔离级别下可以重复读,但还是存在幻读,具体怎么实现我们后面讲锁的时候在分析.

- 4.串行化  所有的事物都串行,这样就规避了对共享资源的竞争,所以可以规避,可重复读,脏读,不可重复读 等问题,但是严重牺牲了性能.

- 5.快照读 以上为SQL92标准定义的4种隔离级别,但是后来数据库的实现又出现了一种新的隔离级别,就是快照读,这种方式利用了CopyOnWrite技术,在多个事物执行的时候会记录数据的一个快照,就是每个数据都有一个版本,读的时候可以不用和写冲突,当有还没有提交的写操作的时候,读可以直接读取未提交的事物之前的版本.避免了加锁操作.


- D.持久性 事物完成后，该事物对数据库的更改便持久的保存在数据库中，写完数据后数据不丢.如何保证数据不丢呢? 我们可以将数据写到多个磁盘保证一个磁盘损坏后数据不丢，如何保证写到多个磁盘可以同时写入成功或者同时失败,这也需要用到事物的原子性,目前数据库一般采用RAID实现,不可能每次写数据都要sync到磁盘，性能太差，肯定会再内存缓存，在刷到磁盘，但是内存在断电会丢,所以mysql会用WAL技术,write ahead logging,写数据的时候先写入redolog,redolog是顺序写,速度很快,等redolog满了或者空闲的时候在把redolog里的记录写入磁盘上的某一个具体数据页.innodb采用redolog来保证mysql的crashsafe的能力.


> 解决事物的方法

要满足事物的一致性需求,我们需要协调事物之间对资源的竞争,管理一个事物的写是否对另外一个事物可见(读),一个事物在写的时候是否允许其他事物写,写包括修改和插入,这个时候我们有必要分析下几种锁的实现.

- 串行  这种情况相当于所有的操作都串行,无论是读操作还是写操作,不管是否有资源竞争,统一按顺序单线程执行,不做任何冲突检测
- 排他锁 针对有锁竞争的资源进行排队,需要检测是否有冲突,一个事实在对记录A读,就不允许其他事物对记录A进行读,更不允许写,但是允许对记录B读写
- 读写锁 在排他锁的基础上,允许两个事物同时读,允许读读,不允许读写,写读,写写
- MVCC  多版本并发控制,允许写读,在写的时候读操作可以读取到历史版本的数据,主要依托于mysql的undolog进行计算,允许写得时候读,这个极大的提高了mysql的QPS,减小了锁的力度,所以现在大部分数据库都有实现MVCC

以上分析了几种锁的实现,但是我发现有人会对乐观锁和悲观锁有错误的认识,我们也简单分析下,乐观还是悲观是争抢锁的时候处理方式不同,获取到锁之后的处理是一样的,悲观锁,故名思议,他比较悲观,认为肯定有其他人会和他争抢锁他抢到锁的概率很小,而且认为别人会将锁持有很长时间,所以当去获取锁的时候如果发现锁已经被占有,就释放cpu一直等待,直到占有者释放锁在通知他去争抢,而乐观锁认为应该没有人或者很少有人会和自己竞争,所以他会先去获取锁如果没获取到他就会自旋一段时间然后在去尝试获取,自旋的时候并不会释放CPU资源,而悲观锁会释放CPU资源进行等待,因为他比较悲观,以为要很久才获取的到锁,如果不释放CPU一直空等待,那么别人将无法获取到cpu资源影响性能,而悲观锁觉得占有者很快就会释放所以不会占有很长时间,因为如果释放CPU下次获取到锁还会额外有CPU上下文切换的开销,还不如自己持有CPU不释放.
而公平锁和非公平锁,是在竞争同一把锁的时候,维护一个队列,先进来的先获取锁,后来的后获取锁,很公平,非公平锁为了节省CPU上下文切换,当占有者释放锁的时候,在队列之外另一个锁争抢者正好尝试获取锁,那么就把锁给这个竞争者,而不是让他进入队列等待,然后取队尾竞争者,这个就是公平锁和非公平锁的区别.


> 处理事物面临的问题

- 怎么构建read-view


- 死锁检测

  我们先通过哲学家问题,来回顾下死锁的发生. 5个哲学家围做一个餐桌，餐桌上有一盘意大利面，每两个哲学家之间放一把餐叉，哲学家必须分别左手和右手都拿到餐叉才能吃东西，如果每个哲学家都左手拿一把餐叉，等右边的餐叉就产生死锁，可以设计一个超时时间，如果5分钟后拿不到就放开左边的餐叉过5分钟在尝试，但是如果5个人同时进入餐厅还是会产生死锁，一种解法是餐厅有个服务生作为协调，哲学家拿餐叉需要经过服务生的同意，另外一种解法是，将餐叉编号，哲学家按顺序从一个方向获取，如果做成一个环释放的可以被其他人获取就是一个ringbuffer

  数据库里面的所有的写其实都是先读取,insert需要先查询看是否有唯一索引冲突,update需要先查询出来在内存中修改后在写会缓存行,删除需要先查询出来然后在进行删除操作,所以我们队数据库的操作对数据库而言还需要进行拆分,因为我们的update对数据库而言并不一定是一个原子操作,需要将这些操作拆分后在进行是否存在共享资源的竞争问题,然后在进行加锁操作,如果一个事物获取到A锁,想要获取B锁,此时另外一个事物获取到B锁想要获取A锁,就出现了死锁.

  那么数据库是如何做死锁检测呢?
todo

- 故障恢复


todo

### mysql的锁机制

todo




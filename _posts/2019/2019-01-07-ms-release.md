---
layout:     post
title:    轻松构建微服务之高效发布
no-post-nav: true
category: other
tags: [arch]
excerpt: Devops 持续集成 蓝绿发布
---

## docker

namespace : docker在创建容器进程的时候可以指定一组namespace参数，这样容器就只能看到当前namespace所限定的资源，文件，设备，网络。用户，配置信息，而对于宿主机和其他不相关的程序就看不到了，PID namespace让进程只看到当前namespace内的进程，Mount namespace让进程只看到当前namespace内的挂载点信息，Network namespace让进程只看到当前namespace内的网卡和配置信息，

cgroup : 全名;linux control group，用来限制一个进程组能够使用的资源上限，如CPU，内存，网络等，另外Cgroup还能够对进程设置优先级和将进程挂起和恢复，cgroup对用户暴露的接口是一个文件系统，/sys/fs/cgroup下 这个目录下面有 cpuset,memery等文件，每一个可以被管理的资源都会有一个文件，如何对一个进程设置资源访问上限呢？在/sys/fs/cgroup目录下新建一个文件夹，系统会默认创建上面一系列文件，让后docker容器启动后，将进程ID写入taskid文件中，让后根据docker启动时候传人的参数修改对应的资源文件

文件系统：用Mount namespace隔离后，但是docker容器还是依赖宿主机的文件系统，通过chroot来更改change root file system更改进程的根目录到指定的位置，一般会通过chroot挂载一个 linux的文件系统不包括linux内核，这样当我们交付一个docker镜像的时候不仅包含需要运行的程序还包括这个程序依赖运行的这个环境，因为我们打包了整个依赖的linux文件系统，对一个应用来说，操作系统才是他所依赖的最完整的依赖库，

增量层：docker在镜像的设计中引入层的概念，也就是用户在制作docker镜像中的每一次修改都是在原来的rootfs上新增一层roofs,之后通过一种联合文件系统union fs的技术进行合并，合并的过程中如果两个rootfs中有相同的文件则会用最外层的文件覆盖原来的文件来进行去重操作，举个例子，我们从镜像中心pull一个mysql的镜像到本地，当我们通过这个镜像创建一个容器的时候，就在这个镜像原有的层上新加了一个增加层的roofs,这个文件系统只保留增量修改，包括文件的新增删除，修改，这个增量层会借助union fs和原有层一起挂载到同一个目录，这个增加的层可以读写，原有的其他层只能读，这样保证了所有对docker镜像的操作都是增量，之后用户可以commit这个镜像将对这个镜像的修改生成一个新的镜像，新的镜像就包含了原有的层和新增的层，只有最原始的层才是一个完整的linux fs, 那么既然只读层不允许修改，那么我怎么删除只读层的文件呢，这个时候只需要在读写层也就是最外层生成一个whiteout文件来遮挡原来的文件就可以了，


dockerfile 可以通过docfile生成一个镜像，docfile里面可以指定 from的原始镜像，以及自定义操作例如拷贝文件等，容器启动命令等

kubernets 一个做容器编排和调度的工具，kubernets的最小调度单元是POD，一个POD可以管理一组同生命周期的容器，k8s提供一个restful的客户端api供用户使用，所以会有一个APIserver来接受请求，通过etcd作为数据库来存储请求中得CRUD操作，而其他模块例如控制器中的调度单元，会扫描数据库中的记录，如果有新的POD还没有分配物理节点，则会执行调度动作，如果发现新增了副本数量，就会增加POD副本，如果修改了POD相关配置就去执行，而每一个节点上面都会允许一个kube-proxy用来接收外部请求后转发，而docker采用的插拔容器，可以使用docker引擎，也可以用其他的引擎。




## k8s
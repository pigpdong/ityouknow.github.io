---
layout:     post
title:    轻松构建微服务之高效缓存
no-post-nav: true
category: other
tags: [arch]
excerpt: redis集群,cdn缓存
---

## 前言

缓存

1.容量评估
 缓存系统主要消耗的是服务器内存，因此使用缓存时候必须对应用需要缓存的数据大小进行评估，包括缓存的数据结构，过期时间，缓存大小，缓存数量，然后根据未来一定时间内的业务增长情况进行预估

建议将使用的缓存进行分离，核心业务和非核心业务可以使用不同的缓存实例，最好能做到业务之间相互隔离，避免不同业务线共用一套缓存导致冲突
所有的缓存实例都需要有监控，内存使用情况，慢查询，大对象
任何缓存key都设置过期时间，过期时间最好在原有设置上加减一个随机值，避免一起失效导致雪崩。
先更新数据库，后失效缓存
先失效缓存在更新数据库，导致此时出现并发读的情况下，这个时候缓存失效了无法命中，而数据库还没更新，那么新的查询操作会将旧的数据从数据库查询出来并写入缓存，导致缓存数据和数据库不一致，而且这种情况会一直持续下去，而且在更新的时候并发读的概率很高
先更新数据库在失效缓存，如果在更新完数据库还没有失效缓存，这个时候新的读会命中缓存从而获取脏数据，而在缓存失效后，数据会恢复正常
先写库在更新缓存也有脏读，但是概率很小 一个读操作没有命中缓存，这个时候去数据库去取，这个时候正好一个写操作进来，更新和失效缓存后，之前的读操作将之间的旧数据设置到缓存里， 这种情况出现的概率很小，这个读操作出现在两次写数据之间，或者正好缓存过期了
所以先写数据库还是先清空缓存可能需要依赖具体业务进行特殊考虑，例如对于商品份额这种当然是先更新数据库在清空缓存

数据的最终一致性最好不要依赖缓存

可以借助canel订阅mysql的binlog日志，然后异步更新redis的缓冲，这样可以做到部分解耦

对于性能要求很高的可以借助JVM缓存，JVM缓存会导致各个节点之间数据不一致，这个时候需要应用程序自行处理数据不一致的问题，当然也可以借助工具将各个JVM之间的内存进行节点间的同步

redis集群部署  写的时候 操作主节点，并且根据选slot算法找到指定的 master节点，但是读的时候我们允许去slave节点读取，对于slave节点能否让同一个机房的应用去对应的slave去取，而不用让所有的slave节点都需要维护到所有应用的长连接
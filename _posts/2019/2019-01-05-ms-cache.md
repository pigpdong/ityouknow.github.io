---
layout:     post
title:    轻松构建微服务之高效缓存
no-post-nav: true
category: other
tags: [arch]
excerpt: redis集群,cdn缓存
---

## 前言

在分布式系统中最好耗性能的地方就是最后端的数据库,一般情况下数据库上的insert操作很快,而update和delete操作如果带有索引也不会慢,前提要控制好单表的数据量,并且不要建太多索引,
而最容易出现性能问题的往往是select语句,我们抛开join和group不说,大多数应用都是读多写少而且,而且带有排序和limit等耗时操作,有些查询还需要根据非索引字段进行过滤,以及like操作会加剧慢查询,
在微服务中这些查询接口往往以rpc的形式对外提供服务,因为网络开销导致整体响应时间增加,所以在某些性能要求较高的业务中引入缓存是非常必要的,下面我们将引入缓存的具体位置进行分类介绍.

![](https://pigpdong.github.io/assets/images/2019/cache/cache.png)


### 客户端缓存
移动客户端可以将一些静态资源缓存在设备上,避免重复从应用层获取,在网络不通畅的情况下也可以避免没有数据前端UI错乱,
而PC端浏览器一般可以通过nginx设置cache-control,expires,if-modified-since来控制缓存,避免重复请求服务器,也可以通过
cookie将一部分数据存在用户浏览器中,下次请求可以将cookie发送给服务端,一般用cookie存储用户登录信息


### CDN缓存
一些静态资源,尤其是图片,我们可以在高并发的情况下,让用户优先访问离用户最近并且同一个网络供应商的CDN节点,避免跨运营商垮地域访问,
相比于集中式的机房内的服务器,CDN厂商的覆盖范围更广,在每个运营商,每个地区都有自己的POP点,所以总可以找到更加靠近用户网络的CDN节点就近获取静态资源,CDN节点一般用来存储
不频繁变更的静态图片,页面等资源,一般发布新版本,或者上新一个新活动都可以提前将这些静态资源提前推送到CDN节点进行预热,使用CDN一般通过CNAME的方式将域名解析交给CDN厂商的DNS服务器和全局负载均衡器

![](https://pigpdong.github.io/assets/images/2019/cache/cdn.jpeg)


### 反向代理层缓存
反向代理层一般需要做动静分离,将静态资源存在在ngnix本地,静态资源一般数据库大请求频繁,做动静分离可以使应用层可以有更多资源处理动态请求,而静态资源不用直接请求应用层,可以极大提高系统吞吐量
在做了动静分离后,浏览器可以直接通过ajax请求服务端获取动态数据,浏览器将数据进行整合后显示给用户.

### 分布式缓存

![](https://pigpdong.github.io/assets/images/2019/cache/cacheflow.png)
![](https://pigpdong.github.io/assets/images/2019/cache/cacheflow2.png)

目前分布式缓存一般单独部署在应用层进行读写控制,读取的时候先去查询缓存服务器,没有命中在去查询数据库并写入缓存,更新的时候先更新数据库,然后在将缓存失效,
使用分布式缓存来替代应用层在JVM内缓存,可以避免各个JVM内缓存不一致的情况,也让缓存可以集群化部署更容易水平扩展,

目前分布式缓存主要由memecache和redis,memecache主要提供key-value存储,内存使用率较高,对大数据性能较好,但是集群支持不友好

而redis提供多种数据结构,string,set,list,zset,hash等,还提供了RDB全量持久化,和AOF增量持久化,不过开启持久化后会影响redis的内存使用率,尤其是开启AOF同步后还会影响redis的写性能,redis还提供了集群的功能.


![](https://pigpdong.github.io/assets/images/2019/cache/redis.jpg)

redis提供分片功能,将整个集群的16384个slot根据服务器的性能和读写频率分道不同的master节点上,每个master可以下挂若干个slave节点,slave从master异步同步数据,当master挂了之后,slave可以通过选举生成新德master,
master可以提供读写服务,而slave只提供读服务,而redis集群对外提供服务也可以单独加一层proxy也可以直接连接客户端,两种方式各有利弊,可根据实际场景进行选择



### JVM本地缓存

本地缓存,这类缓存一般存储在JVM堆空间内,由于容量受限制,也会影响到FullGC,当然也可以考虑使用堆外内存或者用jemalloc管理内存,
所以我们只是通过本地缓存来缓存一些并发访问量特别高并且查询数据库很耗时的数据,而且这类数据可能不一定和数据库完全保持一致,所以业务不会使用改变量做一些金额和状态相关的核心操作.
这类缓存的典型代表为guava和ehcache,也有一些缓存放在ORM框架中,去缓存数据中的查询操作.


### 数据库缓存

数据库本身也会有缓存功能,目前建议只针对一些读多写少特别频繁的业务表开启,大多数情况都建议关闭,因为mysql的缓存中当有任何一条记录的update操作就会将缓存失效,如果频繁update就会导致数据库频繁缓存和清除


### 使用说明

- 容量评估

在使用缓存前,最好做下容量评估,缓存系统主要消耗的是服务器内存，因此使用缓存时候必须对应用需要缓存的数据大小进行评估，包括缓存的数据结构，过期时间，缓存大小，缓存数量，然后根据未来一定时间内的业务增长情况进行预估.

- 业务分离

建议将使用的缓存进行分离，核心业务和非核心业务可以使用不同的缓存实例，最好能做到业务之间相互隔离，避免不同业务线共用一套缓存导致冲突.

- 监控

所有的缓存实例都需要有监控，内存使用情况，慢查询，大对象,任何缓存key都设置过期时间，过期时间最好在原有设置上加减一个随机值，避免一起失效导致雪崩。

- 先更新数据库，后失效缓存

以下为先更新数据库后清缓存的两种情况,一种最后缓存清空后下一次读请求就会恢复,另外一种发生的概率很小
![](https://pigpdong.github.io/assets/images/2019/cache/cache1.jpg)

以下为先清缓存后更新数据库,会导致缓存中得数据一直是脏数据
![](https://pigpdong.github.io/assets/images/2019/cache/cache2.jpg)

- 应用不要过渡依赖缓存

我们一般不会要求缓存服务器的更新和数据库的更新在同一个事物内,所以肯定有概率缓存和数据库不一致的情况,所以
数据的最终一致性最好不要依赖缓存,可以在应用层和或者数据库CAS的方式增加校验,另外应用也不应该严重依赖缓存,当缓存服务器挂掉之后至少要保证服务能够在没有高并发情况下继续正常对外提供服务,
当然也不要过渡依赖缓存服务器的持久化功能,毕竟并不能完整复原历史数据.




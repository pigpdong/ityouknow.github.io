---
layout:     post
title:    轻松构建微服务之消息队列
no-post-nav: true
category: other
tags: [arch]
excerpt: 消息队列
---

## 前言

在早开始接触消息队列是ActiveMQ,由于ActiveMQ是支持JMS规范的,但是由于微服务的兴起,传统的消息队列和JMS规范已经无法满足应用分布式部署的需求,所以后续出来一些消息中间件已经不在严格遵守JMS规范,例如我们今天会分析的rocketMQ.

> JMS规范是一套类似于jdbc的接口,他提供了发送和接收消息相关的API,各个消息中间件都会实现该api,这样在使用不同厂商的消息中间件的时候可以使用同一套接口.JMS规范定义了,消息的发送者,接收者,点对点,发布与订阅,消息队列queue,消息主题topic.拉取消息的模式.

## rocketMQ

rocketMQ是阿里巴巴开源的一套分布式消息中间件,提供了消费者和生产者都可以弹性扩展的能力,并且多消息的消费速度可以自动进行流控,避免消息拉取太快,而消息处理速度跟不上,同时提供了亿级的消息堆积能力,同时提供了顺序消息,事物消息,消息过滤,消息失败重试等,同时消息持久化到磁盘避免消息丢失,支持消息回溯,使消费者可以重新到指定的时间重新进行消费,当然选择rocketmq主要还有以下原因,活跃的社区和经历过双十一的考验.

## 组件介绍

> NameServer  名字服务,类似于ZK的注册功能,nameServer接受broker的注册和注销请求以及topic和broker的管理信息,consumer和producer通过nameserver获取某个topic下的所有的queue,以及queue分配在哪个broker上的
> topic 消息的主题,一般某一个具体的业务会在broker上创建一个消息topic,一个topic可以有不同的消费组,每个consermer group之间的消费互不影响
> queue 消息队列,逻辑上可以指具体存储消息的地方,(实际上消息存储在磁盘上),而一个topic可以创建多个queue,每个queue可以被不同consumer group同时进行消费.
> Consumer 消息的消费端,可以支持集群部署,订阅某一个topic后,可以从这个topic对应的queue上拉取消息,目前虽然支持pull和push,但是建议使用pull开控制消费速度
> Provider 消息的生产者,可以支持集群部署,当和一个topic关联后,可以将消息推送到broker上进行存储
> Provider Group 一类producer的集合,这些producer往往在一个集群内,发送同一个消息,当发送事物消息的时候,如果消息队列需要去producer进行反查,如果某一个producer挂了可以去这个group下的其他producer查询
> Consumer Group 一类consumer的集合,避免在consumer集群下,每个consumer都会订阅某个topic后收到消息后重复处理,同一个group下的所有consumer只有一个会收到消息并处理
> Broker 消息服务器,支持集群部署,负责存储消息,维护消息发送的状态,并将topic信息发送给nameserver

## 部署模型

![](https://pigpdong.github.io/assets/images/2019/mq/bushu.png)

- 单Master模式  单点风险
- 多Master模式  靠RAID保证消息不丢,会丢失部分消息
- 多Master多Slave master宕机后,对应的slave跟上去,但是如果master和slave之间的复制有同步和异步,同步会降低吞吐量,异步可能会有少量消息丢失.

## 拉取模式

RocketMQ采用推拉结合的模式,客户端以一定频率向broker拉取指定队列上是否有消息,如果有消息就批量拉取,如果没有消息就等待,直到超时或者有消息在返回,而服务端收到生产者的消息后也会主动推送给客户端一个通知,客户端收到通知后会主动过来拉取消息,这种模式可以在最大程度上保证消费者可以按自己的处理速度去消费.

## 消息过滤

消息过滤可以实现,MessageFilter接口,读取消息属性进行过滤,也可以直接通过tag来实现

## 顺序消息

要严格保证消息的顺序,那么只能有一个队列了,当然如果使用主从,也可以保证大部分的顺序

## 消息回溯

消费者如果要回溯到1个小时以前的节点重新进行消费,可以在broker上重置queue的offset,因为每一个consumergroup在broker上都维护了对应的队列的消费位置,每次都从指定位置拉取消息,如果要重塑只需要根据时间reset这个offset的值


## 事物消息

rocketMQ通过一个叫半消息(Half Message)的服务来实现事物消息,使用方需要将本地事物和消息发送放在一个事物内,当本地事物提交或者回滚的时候通知消息服务器提交和回滚,如果本地服务发给消息服务器的提交或者回滚请求没有响应,消息服务器可以定时查询所有没有提交的消息,去服务提供方查询消息的状态,看是提交还是回滚.


## 云原生

计算和存储分离



















RocketMQ
消息队列的三大好处：应用解耦，流量削峰，消息分发

消息拉取的三种模式：循环拉，实时推送，长轮询拉结合推送有消息让后客户端去批量拉

实时推回加大broker的负担，影响性能，其次client的处理能力不相同，如果client不能及时处理消息可能会有潜在问题
pull循环的间隔时间不好控制，设置的太久影响失效，设置太短可能每次都没有新消息浪费资源
长轮询方式客户端请求后，服务端等到有消息后在返回。客户端拉取的时候可以设置一个broker最长阻塞时间，一般为15秒，长轮询方式的弊端会试需要占有broker资源，这种只适合在客户端连接数可控的情况下

流控情况：客户端可以根据自己的负载进行控制，客户端pull到消息后悔放到线程池里处理，很难监控和控制，例如怎么知道当前消息堆积的数量，哪些消息处理失败，rocketmq用一个processqueue来维护从broker获取到但是还没有处理的消息，用读写锁控制多个线程对ProcessQueue的访问，然后通过ProcessQueue做流控，就是每次去broker拉取消息的时候都会在ProcessQueue里判断当前未处理消息的数量





一个topic可以设置多个queue,这样生产者就可以并行的向多个队列发送消息，消费者也可以同时从不同的queue获取消息，